#!/usr/bin/python

import numpy as np
import gmpy2
from gmpy2 import mpfr
from .constants import constants
from .math_mpfr import *  # cube, d1r, d2r
from .spine_domain_base import GenericSpineDomain


# set preciosion of mpfr variables
gmpy2.get_context().precision = constants['precision']

class SpineNeck(GenericSpineDomain):

    def __init__(self, r1, eps1, r2, eps2, r3, eps3, grid_spacing='log'):
        GenericSpineDomain.__init__(self, r1, eps1, r2, eps2, r3, eps3, grid_spacing)
        self.domain = 'neck'

    def d_c(self, n, r, c_r, charge_number):
        """
        derivative of concentration
        d/dr c(r) for r = r_n
        """
        # make regerences
        eps = self.CONST_eps_0 * self.eps_r[n]
        r_n = self.grid_points[n]
        E_rn = self.electric_field[n]
        # compute excess charge density at r_n
        excess_charge = self.CONST_e * (self.charge_number_c_pos * self.concentration_positive[n] 
                                      + self.charge_number_c_neg * self.concentration_negative[n] 
                                      + self.charge_number_c_back * self.concentration_background[n])
        
        # compute d/dr c = f(r,c) at r_n and return
        return charge_number * self.CONST_EBT * c_r  * (
                   E_rn + (r - r_n) / r / eps * r_n * excess_charge
               )
               
    def compute_electric_field(self, n):
        """
        compute electric field at r_{n+1} 
        this assumes that 
        fields at r_n is known
        concentrations at r_{n+1} are already computed
        E_r(r_{n+1}) = E_r(r_n) * r_n / r_{n+1} + 1 / eps / r_{n+1} * (r_{n+1} - r_n) (r_n * rho(r_n)+ r_{n+1}*rho(r_{n+1})) / 2
        above formula uses trapezoidal rule
        n: step
        """
        
        # make references
        eps_n = self.CONST_eps_0 * self.eps_r[n]  # at r_n
        eps_np1 = self.CONST_eps_0 * self.eps_r[n+1]  # at r_{n+1}
        r_n = self.grid_points[n]
        r_np1 = self.grid_points[n+1]
        e_n_pos = self.electric_field_pos[n]
        e_n_neg = self.electric_field_neg[n]
        e_n_back = self.electric_field_back[n]
        
        # compute term coming from trapezoidal rule
        trap_term_pos = self.CONST_e * self.charge_number_c_pos * (r_n * self.concentration_positive[n] + 
                                                                 r_np1 * self.concentration_positive[n + 1]) / mpfr('2')
        
        trap_term_neg = self.CONST_e * self.charge_number_c_neg * (r_n * self.concentration_negative[n] + 
                                                                 r_np1 * self.concentration_negative[n + 1]) / mpfr('2')
        
        trap_term_back = self.CONST_e * self.charge_number_c_back * (r_n * self.concentration_background[n] + 
                                                                   r_np1 * self.concentration_background[n + 1]) / mpfr('2')
                                        
        
        # update electric field at r_{n+1}
        # multiply electric field at r_{n} by eps_n / eps_{n+1} to account for changes in the permittivity
        # this is expecially important at the membrane where the pemittivity changes abruptly
        self.electric_field_pos[n+1] = r_n / r_np1 * e_n_pos * eps_n / eps_np1 + 1 / eps_np1 / r_np1 * (r_np1 - r_n) * trap_term_pos
        self.electric_field_neg[n+1] = r_n / r_np1 * e_n_neg * eps_n / eps_np1 + 1 / eps_np1 / r_np1 * (r_np1 - r_n) * trap_term_neg
        self.electric_field_back[n+1] = r_n / r_np1 * e_n_back * eps_n / eps_np1 + 1 / eps_np1 / r_np1 * (r_np1 - r_n) * trap_term_back
        self.electric_field[n+1] = self.electric_field_pos[n + 1] + self.electric_field_neg[n + 1] + self.electric_field_back[n + 1] + self.electric_field_mem_in[n + 1] + self.electric_field_mem_out[n + 1]
        
    def compute_e_field_membrane_charge_in(self):
        """
        compute electric field generated by membrane charges on the inner membrane surface
        the electric field at the surface can easily be computed from the integral form of gauss' law
        the the field drops with r_n/r_{n+1}
        """
        
        self.electric_field_mem_in[self.res_in] = self.sigma_surf_in / self.CONST_eps_0 / self.eps_r_mem
        
        for i in range(self.res_in+1, self.res_in+self.res_mem+self.res_out-2):
            # i: index where field is computed
            
            # make references
            j = i - 1
            eps_i = self.CONST_eps_0 * self.eps_r[i]
            eps_j = self.CONST_eps_0 * self.eps_r[j]
            r_i = self.grid_points[i]
            r_j = self.grid_points[j]
            e_mem_in_j = self.electric_field_mem_in[j]
            
            # compute field
            self.electric_field_mem_in[i] = r_j / r_i * e_mem_in_j * eps_j / eps_i
            
            
    def compute_e_field_membrane_charge_out(self):
        """
        compute electric field generated by membrane charges on the outer membrane surface
        the electric field at the surface can easily be computed from the integral form of gauss' law
        the the field drops with r_n/r_{n+1}
        """
        
        self.electric_field_mem_out[self.res_in+self.res_mem-1] = self.sigma_surf_out / self.CONST_eps_0 / self.eps_r_out
        
        for i in range(self.res_in+self.res_mem, self.res_in+self.res_mem+self.res_out-2):
            # i: index where field is computed
            
            # make references
            j = i - 1
            eps_i = self.CONST_eps_0 * self.eps_r[i]
            eps_j = self.CONST_eps_0 * self.eps_r[j]
            r_i = self.grid_points[i]
            r_j = self.grid_points[j]
            e_mem_out_j = self.electric_field_mem_out[j]
            
            # compute field
            self.electric_field_mem_out[i] = r_j / r_i * e_mem_out_j * eps_j / eps_i
         
        
            
    def compute_cumulative_charge(self):
        """
        computes cumulative charge distribution by integration of charge distributions
        uses trapezoidal rule for integration
        for polar symmetry the cumulative charge per length unit is computed
        unit [C/m]
        Q(r) = \int_0^r 2*pi*sigma(r) r dr
        """
        
        # cumulative charge distribution for charges on inner side of membrane
        for i in range(self.res_in,  self.res_in+self.res_mem+self.res_out-2):                          
            self.cumulative_mem_in[i] = mpfr('2') * self.CONST_PI * self.grid_points[self.res_in] * self.sigma_surf_in
        
        # cumulative charge distribution for charges on outer side of membrane 
        for i in range(self.res_in+self.res_mem-1,  self.res_in+self.res_mem+self.res_out-2):    
            self.cumulative_mem_out[i] = mpfr('2') * self.CONST_PI * self.grid_points[self.res_in+self.res_mem-1] * self.sigma_surf_out
        
        # cumulative charge distribution for intra- and extracellular charges
        for i in range(1, self.res_in+self.res_mem+self.res_out-2):
            # positive charges
            self.cumulative_positive[i] = (self.cumulative_positive[i-1]
                + mpfr('2') * self.CONST_PI * 
                ((self.grid_points[i] - self.grid_points[i-1]) / mpfr('2') * 
                 (self.grid_points[i] * self.concentration_positive[i] * self.charge_number_c_pos + 
                 self.grid_points[i-1] * self.concentration_positive[i-1] * self.charge_number_c_pos)) 
                 * self.CONST_e)
            # negative charges
            self.cumulative_negative[i] = (self.cumulative_negative[i-1] 
                + mpfr('2') * self.CONST_PI * 
                ((self.grid_points[i] - self.grid_points[i-1]) / mpfr('2') * 
                 (self.grid_points[i] * self.concentration_negative[i]* self.charge_number_c_neg + 
                  self.grid_points[i-1] * self.concentration_negative[i-1] * self.charge_number_c_neg)) 
                  * self.CONST_e)
            # background charges
            self.cumulative_background[i] = (self.cumulative_background[i-1]
                + mpfr('2') * self.CONST_PI * 
                ((self.grid_points[i] - self.grid_points[i-1]) / mpfr('2') * 
                (self.grid_points[i] * self.concentration_background[i]* self.charge_number_c_back + 
                 self.grid_points[i-1] * self.concentration_background[i-1]* self.charge_number_c_back)) 
                 * self.CONST_e)
            # sum of positive, negative, background, intracell.- and extracell 
            # side of membrance charges
            self.cumulative[i] =  (self.cumulative_positive[i] 
                                + self.cumulative_negative[i] 
                                + self.cumulative_background[i] 
                                + self.cumulative_mem_in[i] 
                                + self.cumulative_mem_out[i])
    
    def compute_pnp(self):
        self.compute_pnp_lhs()
        self.compute_pnp_rhs()
    
    def compute_pnp_lhs(self):
        """
        compute left hand side of equation (10) in Cartailler, Schuss and Holcman 2016
        """
        # intracellular space
        for i in range(1, self.res_in - 1):
            self.pnp_lhs[i] = d2r(self.grid_points, self.electric_potential, i) + mpfr('1') / self.grid_points[i] * d1r(self.grid_points, self.electric_potential, i, method='cd')
            
            
        # extracellular space
        for i in range(self.res_in+self.res_mem,self.res_in+self.res_mem+self.res_out-3):
            self.pnp_lhs[i] = d2r(self.grid_points, self.electric_potential, i) + mpfr('1') / self.grid_points[i] * d1r(self.grid_points, self.electric_potential, i, method='cd')        
            
    def compute_pnp_rhs(self):
        """
        compute right hand side of equation (10) in Cartailler, Schuss and Holcman 2016 but with different boundary conditions
        this equations is the same for spherical and polar symmetry
        """

        # 1. intracellular space
        
        # make reference for permittivity
        eps_in = self.eps_r_in * self.CONST_eps_0     
        
        c_pos_0 = self.concentration_positive[0]
        c_neg_0 = self.concentration_negative[0]
        
        zec_0_pos_in = mpfr('-1') * self.charge_number_c_pos * self.CONST_e * c_pos_0 / eps_in
        zec_0_neg_in = mpfr('-1') * self.charge_number_c_neg * self.CONST_e * c_neg_0 / eps_in                          
        
        pnp_rhs_in_back = mpfr('-1') *  self.charge_number_c_back * self.CONST_e * self.c_back_0_in / eps_in
        
        for i in range(0, self.res_in - 1):
            pnp_rhs_in_pos = zec_0_pos_in * gmpy2.exp( mpfr('-1') * self.charge_number_c_pos * self.CONST_EBT * self.electric_potential[i])
            pnp_rhs_in_neg = zec_0_neg_in * gmpy2.exp( mpfr('-1') * self.charge_number_c_neg * self.CONST_EBT * self.electric_potential[i])
            
            self.pnp_rhs[i] = pnp_rhs_in_pos + pnp_rhs_in_neg + pnp_rhs_in_back
           
        # 2. extracellular space  
        
        # make reference for permittivity
        eps_out = self.eps_r_out * self.CONST_eps_0   
        
        c_pos_0 = self.concentration_positive[self.res_in+self.res_mem-1]
        c_neg_0 = self.concentration_negative[self.res_in+self.res_mem-1]
        phi_0 = self.electric_potential[self.res_in+self.res_mem-1]
        
        zec_0_pos_out = mpfr('-1') * self.charge_number_c_pos * self.CONST_e / eps_out * c_pos_0 
        zec_0_neg_out = mpfr('-1') * self.charge_number_c_neg * self.CONST_e / eps_out * c_neg_0        
        
        pnp_rhs_out_back = mpfr('-1') * self.charge_number_c_back * self.CONST_e * self.c_back_0_out / eps_out
        
        for i in range(self.res_in+self.res_mem-1, self.res_in+self.res_mem+self.res_out-2):
            pnp_rhs_out_pos = zec_0_pos_out * gmpy2.exp( mpfr('-1') * self.charge_number_c_pos * self.CONST_EBT * (self.electric_potential[i]-phi_0))
            pnp_rhs_out_neg = zec_0_neg_out * gmpy2.exp( mpfr('-1') * self.charge_number_c_neg * self.CONST_EBT * (self.electric_potential[i]-phi_0))
            
            self.pnp_rhs[i] = (pnp_rhs_out_pos + pnp_rhs_out_neg + pnp_rhs_out_back) 

            
            
            
            
            
                                                               
